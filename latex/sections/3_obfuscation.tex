\chapter{Obfuscating NIST candidates}\label{ch:obfuscation}

In this section, we construct encodings for different post-quantum KEMs suitable for use in the pq-obfs protocol.

While such encodings have already been constructed for elliptic curve Diffie–Hellman \cite{CCS:BHKL13, tor-dev-udh, USENIX:WWGH11} as well as for ML-KEM \cite{CCS:GunSteVei24}, other KEMs are also being examined for future use.

TODO: Also cite 64, 62 from Obfuscated Key Exchange? Cite by name?

We take a selection of round 4 candidates of the NIST Post-Quantum Cryptography Standardization, as well as previous candidate schemes which we believe to be of interest.
For each scheme, we describe the generation of public keys and ciphertexts in the original scheme and examine their distributions. We then introduce encoding algorithms from the original public keys and ciphertexts to bitstrings and finally give concrete bounds for uniformity and encoding success rate.

We call all our encoding schemes TODO where TODO is the name of the corresponding KEM. \cref{tab:obfuscation-summary} summarizes the result of the later sections.

TODO: Show domain in table? Update references to convenience definitions earlier.

\begin{table}
    \centering
    \scriptsize\raggedright
    \begin{tabular}{@{} *{2}{L{0.125\textwidth-\tabcolsep}} | *{3}{L{0.25\textwidth-2\tabcolsep}} @{}}
        \textbf{KEM} & \textbf{Encoding} & \textbf{Obfuscation/Ciphertext uniformity} & \textbf{First-Keygen/Encap Success Probability} (\cref{def:first-keygen-success,def:first-encap-success}) & \textbf{Output Size} (in bytes)\\ \hline
        Classic McEliece \cite{NISTPQC-R4:ClassicMcEliece22} & TODO &  &  & \\
         & - public keys & 0.01 & 0.2 & 0.3 \\
         & - ciphertexts & 0.01 & 0.2 & 0.3 \\
         &  &  &  & \\
    \end{tabular}
    \caption{Summary of KEMs, their corresponding encodings and the results of our analysis. The origins of analysis results are specified, and for output sizes, differences in bytes from original public key/ciphertext sizes are given. This table can be viewed as an extension of \cite[Table~2]{CCS:GunSteVei24}.}
    \label{tab:obfuscation-summary}
\end{table}

\section{Classic McEliece as an obfuscated KEM} \label{sec:obfuscating-classic-mceliece}

Throughout this \cref{sec:obfuscating-classic-mceliece}, we use the positive integer variables $m,n,t,k$ where $n < 2^m$ and $k=mt-n$ as defined in \cite{NISTPQC-R4:ClassicMcEliece22}. We work with matrices and vectors over $\mathbb F_2$ when examining the KEM and use bitstrings in the defintion and analysis of OKEMs. As the dimensions of the matrices and vectors are fixed for a given parameter set, we associate the matrices and vectors with their canonical encoding as bitstrings of appropriate length.

\paragraph{Original Generation and Distribution}
Classic McEliece \cite{NISTPQC-R4:ClassicMcEliece22} is a perfectly correct, code-based KEM in round 4 of the NIST PQC standardization. We only consider the so-called "non-f" versions of the specified parameter sets which are interoperable with the f versions, and have simpler but slower key generation.

TODO: OK? Keita also makes that assumption at some point.

In Classic McEliece, public keys are the $k$ rightmost columns of a $mt \times n$ generator matrix in systematic form ($k = n - mt$). Ciphertexts are the $mt$ data bits corresponding to $n$-bit codewords with Hamming weight exactly $t$.

The generation of public keys occurs in a multistep process starting from a 256-bit seed which is expanded using SHAKE256 into a secondary seed and raw values. If the raw values do not form a suitable systematic code, another attempt is started from the secondary seed, and so on. This key generation process, among other algorithms from the Round 4 specification of Classic McEliece are reproduced in \cref{fig:classic-mceliece-spec}.

For encapsulation, rejection-sampling is used to generate a uniformly random vector of Hamming weight exactly $t$ which is then mapped from the space of $n$-bit vectors to $mt=n-k$ bits using the generator matrix defined by the public key.

\begin{figure}
    \input{algorithms/classic-mceliece-spec}
    \caption{A relevant selection of algorithms from the Classic McEliece Round 4 specification \cite{NISTPQC-R4:ClassicMcEliece22}.}
    \label{fig:classic-mceliece-spec}
\end{figure}

We define the same assumptions about computational hardness as in \cite[Definition~K.1]{EC:Xagawa22}. These have appeared in more general forms in previous literature studying the Niederreiter and McEliece cryptosystems, e.g. \cite{AC:CouFinSen01,EC:SaiXagYam18}. \cref{fig:classic-mceliece-assumptions} shows corresponding game-based definitions.
\begin{itemize}
    \item \textbf{modified PR-Key assumption:} It is computationally hard to distinguish real public keys from the rightmost columns of the systematic forms of uniformly random generator matrices (conditioned on the systematic form existing).
    \item \textbf{modified Decisional Syndrome Decoding assumption:} It is computationally hard to distinguish ciphertexts generated using uniformly random generator matrices from uniformly random $(n-k)$-bit vectors.
\end{itemize}

For both games $\textsf{goal} \in \{\prkey, \mdsd\}$, we define the advantage of an adversary $\adv$ as follows and further say that Classic McEliece is $(t, \epsilon)\textsf{-goal}$-secure if for any adversary $\adv$ with running time at most $t$, we have that:
\[ \advantage{\textsf{goal}}{}[(\adv)] := 2 \cdot \Pr[\textsf{goal}(\adv) = 1] - 1 \leq \epsilon \]

\begin{figure}
    \input{algorithms/classic-mceliece-assumptions}
    \caption{Indistinguishability games for Classic McEliece with $\kgen$ and \textsf{FixedWeight} as defined in \cref{fig:classic-mceliece-spec}. These games follow the definitions from \cite[Definition~K.1]{EC:Xagawa22}.}
    \label{fig:classic-mceliece-assumptions}
\end{figure}

\paragraph{Classic McEliece is already obfuscated}

Given the $\prkey$ assumption, public keys are hard to distinguish from outputs of $\textsf{RandGen}()$. We claim that $\textsf{RandGen}()$ can be simplified to a new algorithm $\textsf{RandGen}'()$, also shown in \cref{fig:classic-mceliece-assumptions}, with statistical indistinguishability.

\begin{lemma}[Simplifying \textsf{RandGen}] \label{lem:classic-mceliece-randgen-prime}
    Let $\textsf{RandGen}(), \textsf{RandGen}'()$ be defined as in \cref{fig:classic-mceliece-assumptions}.
    The distributions $D_0 = \{ \hat T \gets \textsf{RandGen}() \}$ and $D_1 = \{ \hat T \gets \textsf{RandGen}'() \}$ are statistically indistinguishable, i.e. have statistical distance $\Delta(D_0, D_1) = 0$.
\end{lemma}

\begin{proof}
    We first examine the rejection sampling behavior around \cref{ln:randgen-reject}: A resampling occurs if and only if a reduction of $\hat H$ to systematic form (also known as \emph{reduced row echelon form} or \emph{row canonical form}) fails. This reduction, in turn, fails if and only if the $mt$ leftmost columns of $\hat H$ do not form a full rank square matrix.
    The probability for a $mt \times mt$ matrix with i.i.d. uniformly random entries over $\mathbb F_2$ to be of full rank is exactly \cite{DBLP:journals/corr/SalmondGGC14}
    \[ p_\textsf{FR} := \prod_{i=1}^{mt} \left( 1-2^{-i} \right) \]
    
    For the parameter sets used in Classic McEliece ($768 \leq mt \leq 1664$), this calculates to \[ p_\textsf{FR} \approx 0.288788 \]
    Differences between the parameter sets are negligible and a strict upper bound of $p_\textsf{FR} \leq \prod_{i=1}^{768} \left( 1-2^{-i} \right) \leq \prod_{i=1}^{8} \left( 1-2^{-i} \right) \leq 0.29$ applies. A proof for a tight lower bound eludes us although the numerical convergence is rapid.
    
    This calculation validates our analysis, as the resulting probability is the same as was experimentally reported in \cite[security.pdf: Section 4.2]{NISTPQC-R4:ClassicMcEliece22}.
    
    We now consider the possible influence that the reduction to systematic form might have on the distribution of bits in the simulated public key $\hat T$.

    Consider an intermediate value of $\hat H$ which can be reduced to systematic form (i.e. has full rank and will pass the check on \cref{ln:randgen-reject}). This value exists precisely once for all terminating executions of $\textsf{RandGen}()$ as the last $\hat H$ sampled before returning a result.

    In general, the reduced row echelon form can be obtained using Gauss–Jordan elimination. This algorithm carries out a sequence of operations on the matrix consisting of swapping rows, adding rows onto others and scaling rows.
    Over $\mathbb F_2$, the scaling of rows is not needed and swapping of rows can be accomplished via a sequence of 3 row additions. Any Gauss-Jordan reduction to systematic form can thus be expressed as merely a sequence of row additions.
    The systematic form of $\hat H$ over $\mathbb F_2$, just like reduced row echelon forms over any field, is also unique. Thus it suffices to consider an arbitrary sequence of row additions transforming $\hat H$ to systematic form.
    
    Due to the number of rows, a reduction is possible in $(mt)^2$ row additions: The diagonal can be filled with ones using at most $mt$ additions. After another $(mt)^2-mt$ additions at the latest, all other entries in the leftmost $mt$ columns are zeroes. To determine one such order of row additions which bring $\hat H$ into systematic form, it suffices to consider only the leftmost $mt$ columns.
    
    Let $M_0$ denote the rightmost columns of $\hat H$, which form (by definition) a $mt \times k$ matrix of uniformly random i.i.d. entries from $\mathbb F_2$, in particular, independent from the leftmost columns of $\hat H$.
    
    As the addition of any one row of uniformly random bits onto any other row of independent uniformly random bits produces a row of uniformly random i.i.d. bits, the resulting matrix after one row addition, say $M_1$, is statistically indistinguishable from $M_0$.
    
    Repeating this argument for a maximum of $(mt)^2$ times, we can conclude that $\hat T$ is statistically indistinguishable from a uniformly random $mt \times k$ matrix over $\mathbb F_2$ as in $\textsf{RandGen}'()$.
\end{proof}

Ciphertexts are also statistically indistinguishable from uniform random bit vectors following the $\prkey$ and $\mdsd$ assumptions. Implementers should note that padding public keys and ciphertexts to the byte boundary may require \emph{randomized} padding. This is only needed if the number of bits is not evenly divisible by 8, and occurs only for the parameter set 'mceliece6960119'.  All other parameter sets have $mt = 0 \mod 8$. Padding of these values with zero bits (as suggested in the specification) would break the public key and ciphertext uniformity.

\begin{theorem}
    Classic McEliece, as specified in \cite{NISTPQC-R4:ClassicMcEliece22}, is an obfuscated KEM without requiring any special encoding of public keys or ciphertexts.

    Classic McEliece, as an OKEM, achieves $\indcca$ and $\sprcca$ security according to \cref{def:ind-spr-cca}.
\end{theorem}
\begin{proof}
    TODO: discuss syntax of OKEM vs KEM

    The $\indcca$ and $\sprcca$ security notions for OKEMs defined in \cref{def:ind-spr-cca} match the established notions of the same names. These have been shown for Classic McEliece in previous work \cite{EC:Xagawa22}, \cite[security.pdf: Section 5]{NISTPQC-R4:ClassicMcEliece22}.

    The $\prkey$ and $\mdsd$ assumptions are not needed here.
\end{proof}

\paragraph{Uniformity}

We analyze the public key and ciphertext uniformity of Classic McEliece and reduce to the two assumptions made above. As no further encoding is done here, there is no discussion of success rate as for other KEMs.
The notions of public key and ciphertext uniformity are discussed in \cref{def:pk-uniformity,def:ctxt-uniformity} respectively.

\begin{lemma}[Public key uniformity of Classic McEliece] \label{lem:classic-mceliece-pk-unif}
    Let $\textsf{CM}$ be the obfuscated KEM defined by the Classic McEliece specification \cite{NISTPQC-R4:ClassicMcEliece22}.
    For any adversary $\adv$ against the public key uniformity of $\textsf{CM}$, there exists an adversary $\bdv$ against the $\prkey$ assumption, such that
    \[ \advantage{\pkunif}{\textsf{CM}}[(\adv)] \leq \advantage{\prkey}{}[(\bdv)] \]
\end{lemma}
\begin{proof}
    The reduction $\bdv$ takes in a public key matrix $T_b$ and forwards its corresponding bitstring to $\adv$. Let $b$ be the output of $\adv$, then $\bdv$ returns the bit $1-b$.

    This perfectly simulates the $\pkunif$ game towards $\adv$ because the output of $\textsf{RandGen}()$ is statistically indistinguishable from $\textsf{RandGen}'()$ as shown in \cref{lem:classic-mceliece-randgen-prime}. The output of $\textsf{RandGen}'()$ corresponds to uniformly random bitstrings as required in $\pkunif$.

    The output bit needs to be flipped as $b=0$ corresponds to the real key generation in the game $\prkey$ but $b=1$ is used to denote the same in the $\pkunif$ game.
\end{proof}

\begin{lemma}[Ciphertext uniformity of Classic McEliece] \label{lem:classic-mceliece-ctxt-unif}
    Let $\textsf{CM}$ be the obfuscated KEM defined by the Classic McEliece specification \cite{NISTPQC-R4:ClassicMcEliece22}.
    For any adversary $\adv$ against the ciphertext uniformity of $\textsf{CM}$, there exist adversaries $\bdv, \cdv$ against the $\prkey$ and $\mdsd$ assumptions respectively, such that
    \[ \advantage{\ctxtunif}{\textsf{CM}}[(\adv)] \leq \advantage{\prkey}{}[(\bdv)] + \advantage{\mdsd}{}[(\cdv)] \]
\end{lemma}
\begin{proof}
    TODO: two-adversary reduction. Revise rest of proof from here!
    
    The reduction $\bdv$ takes in a public key matrix $T_b$ and forwards its corresponding bitstring to $\adv$. Let $b$ be the output of $\adv$, then $\bdv$ returns the bit $1-b$.

    This perfectly simulates the $\pkunif$ game towards $\adv$ because the output of $\textsf{RandGen}()$ is statistically indistinguishable from $\textsf{RandGen}'()$ as shown in \cref{lem:classic-mceliece-randgen-prime}. The output of $\textsf{RandGen}'()$ corresponds to uniformly random bitstrings as required in $\pkunif$.

    The output bit needs to be flipped as $b=0$ corresponds to the real key generation in the game $\prkey$ but $b=1$ is used to denote the same in the $\pkunif$ game.
\end{proof}

\section{Obfuscating ABC with XYZ} \label{sec:tbd}
\paragraph{Original Generation and Distribution}
\paragraph{Constructed Encoding}
\paragraph{Uniformity and Success Rate}

We analyze the public key and ciphertext uniformity of our encoding and reduce to the two assumptions made above. We analyze the success rate of our encoding.

\begin{lemma}[Public key uniformity of TODO TBD] \label{lem:tbd-pk-unif}
    TODO bounds on uniformity
\end{lemma}

\begin{lemma}[Ciphertext uniformity of TODO TBD] \label{lem:tbd-ctxt-unif}
    TODO bounds on uniformity
\end{lemma}

\begin{lemma}[First-keygen success probability of TODO TBD] \label{lem:tbd-first-keygen-success}
    TODO bounds on success
\end{lemma}

\begin{lemma}[[First-encap success probability of TODO TBD] \label{lem:tbd-first-encap-success}
    TODO bounds on success
\end{lemma}

Together with the Classic McEliece KEM, our encoding functions can be used to define a keygen/encapsulate-then-encode obfuscated KEM as in \cref{def:keygen-then-encode,def:keygen-encap-then-encode}.

\begin{theorem}
    Let TODO TBD be a keygen/encapsulate-then-encode obfuscated KEM based on the Classic McEliece KEM as per \cref{def:keygen-then-encode,def:keygen-encap-then-encode}. For any adversary $\adv$ against the $\indcca$ security of TODO TBD, there exists an algorithm $\bdv$ such that
    \[ \advantage{\indcca}{TODO TBD}[(\bdv)] \leq 123 \]

    Further,  For any adversary $\adv$ against the $\sprcca$ security of TODO TBD, there exists an algorithm $\bdv$ such that
    \[ \advantage{\sprcca}{TODO TBD}[(\bdv)] \leq 123 \]
\end{theorem}
\begin{proof}
    IND-CCA security follows from \cite[Theorem~2.12]{CCS:GunSteVei24}, together with \cref{lem:tbd-first-keygen-success,lem:tbd-first-encap-success}.
    
    SPR-CCA security follows from \cite[Theorem~2.13]{CCS:GunSteVei24}, together with \cref{lem:tbd-first-keygen-success}, \ref{lem:tbd-first-encap-success,lem:tbd-ctxt-unif}.
\end{proof}