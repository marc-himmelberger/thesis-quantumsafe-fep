\section{Obfuscating HQC} \label{sec:obfuscating-hqc}

Throughout this \cref{sec:obfuscating-hqc}, we use the integer variables $n, n_1, n_2, w, w_r$ as defined in \cite{NISTPQC-R4:HQC22}.
As in \cref{sec:obfuscating-classic-mceliece}, we work with polynomials and vectors over $\mathbb F_2$ when examining the KEM and use bitstrings in the definition and analysis of OKEMs. As the degrees of the polynomials and the dimensions of the vectors are fixed for a given parameter set, we associate them with their canonical encoding as bitstrings of appropriate length.

\paragraph{Original generation and distribution}
HQC is a code-based KEM selected for standardization as part of the NIST Post-Quantum Cryptography Standardization \cite{nist-standardization,nist-ir-8545}. HQC consists of three parameter sets, namely HQC-128, HQC-192, and HQC-256.
 
In HQC, public keys are pairs of polynomials $(\mathbf h, \mathbf s) \in \mathbb{F}_2[x]$ such that $\mathbf s = \mathbf x + \mathbf h \mathbf y$ where $\mathbf x,\mathbf y,\mathbf h$ have degree $<n$ and $x,y$ have hamming weight exactly $w$.
The HQC ciphertexts are triples $\mathbf u,\mathbf v,\mathit{salt}$ where $\mathbf u$ is a polynomial of degree $<n$, $\mathbf v$ is a bitstring of length $n_1n_2$, and $\mathit{salt}$ is a uniformly random 128-bit string used to derive randomness.

The processes for key generation and encapsulation are reproduced from the Round 4 specification \cite{NISTPQC-R4:HQC22} in \cref{fig:hqc-spec}. That is, public keys are generated by directly sampling appropriate distributions, and encapsulation involves fixing the encryption randomness using $\mathit{salt}$ before encrypting a uniformly random message and deriving the shared secret from the message and the ciphertext.

It has been shown in \cite[Lemma~P.2, Theorem~P.1]{EC:Xagawa22} that HQC-192's $\sprcca$ security (with respect to a simulator that samples $\mathbf u,\mathbf v$ uniformly at random) reduces to the following two assumptions:
\begin{itemize}
    \item the 2-Decisional Quasi-Cyclic Syndrome Decoding (2-DQCSD) assumption \cite[Definition~2.1.15]{NISTPQC-R4:HQC22}
    \item the 3-Decisional Quasi-Cyclic Syndrome Decoding (3-DQCSD) assumption \cite[Definition~2.1.17]{NISTPQC-R4:HQC22}
\end{itemize}

\paragraph{Constructed encoding}

As shown in \cite{EC:Xagawa22}, the parity of $\mathbf u$ depends on the public key parity as $\mathbf u(1)=(1 + \mathbf h(1))w_r \mod 2$. For HQC-192, $w_r = 0 \mod 2$ and ciphertexts therefore always have parity $\mathbf u(1)=0$.

When encoding such a ciphertext, we remove the most significant bit of $\mathbf u$ and pad with random bits up to the byte boundary. The dropped bit can be reconstructed during decoding to obtain the correct parity $\mathbf u(1)=0$.

For the two remaining parameter sets, HQC-128 and HQC-256, the only obstacle in the $\sprcca$ proof of \cite{EC:Xagawa22} is that the $\mathbf u$ component leaks the parity of the public key component $\mathbf h$ and is therefore not fixed as in HQC-192. We can circumvent this issue by rejecting half of all public keys (those with parity $\mathbf h(1)=0$) during key generation.
With this change, the polynomial $\mathbf u$ in the ciphertexts now has parity $\mathbf u(1)=0$ for all three parameter sets and is indistinguishable from uniformly randomly sampled 0-parity polynomials.

The padding with random bits requires (after dropping one bit) the addition of 6, 4, and 6 random bits for the parameter sets HQC-128, HQC-192, and HQC-256, respectively.

TODO: adapt from here

\paragraph{Uniformity and success rate}

We analyze the public key and ciphertext uniformity of our encoding and reduce to the two assumptions made above. We analyze the success rate of our encoding.

\begin{lemma}[[First-keygen Success Probability of TODO TBD]
\label{lem:hqc-first-keygen-success}
    TODO bounds on success = 1/2
\end{lemma}

\begin{lemma}[[First-encaps Success Probability of TODO TBD]
\label{lem:hqc-first-encaps-success}
    TODO bounds on success = 1
\end{lemma}

\begin{lemma}[Ciphertext Uniformity of TODO TBD]
\label{lem:hqc-ctxt-unif}
    TODO bounds on uniformity
\end{lemma}

Together with the TBD KEM, our encoding functions can be used to define a encapsulate-then-encode obfuscated KEM as in \cref{def:encaps-then-encode}.

\begin{theorem}[KEM Security of TODO TBD]
    Let TODO TBD be an encapsulate-then-encode obfuscated KEM based on the HQC KEM as per \cref{def:encaps-then-encode}. For any adversary $\adv$ against the $\indcca$ security of TODO TBD, there exists an algorithm $\bdv$ such that
    \[ \advantage{\indcca}{TODO TBD}[(\bdv)] \leq 123. \]

    Further,  For any adversary $\adv$ against the $\sprcca$ security of TODO TBD, there exists an algorithm $\bdv$ such that
    \[ \advantage{\sprcca}{TODO TBD}[(\bdv)] \leq 123. \]
\end{theorem}
\begin{proof}
    IND-CCA security follows from \cite[Theorem~2.12]{CCS:GunSteVei24}, together with \cref{lem:tbd-first-encaps-success}.
    
    SPR-CCA security follows from \cite[Theorem~2.13]{CCS:GunSteVei24}, together with \cref{lem:tbd-first-encaps-success,lem:tbd-ctxt-unif}.
\end{proof}