\chapter{Implementing drivel}\label{ch:implementation}

This chapter describes implementation efforts, challenges, and noteworthy information for implementers.
\Cref{sec:tech-stack} gives an overview of the technology stack, languages, and libraries used in the implementation, with a particular focus on the changes made to the preexisting lyrebird project \cite{lyrebird} to support \drivel{}. This section also describes the environment in which the protocol was developed and tested.
\Cref{sec:parameters} outlines the process for choosing concrete cryptographic parameters, focusing on the trade-offs between security and traffic volume.
\Cref{sec:protocol-design} presents a high-level description of the \drivel{} protocol, followed by a detailed explanation of how handshake messages could be fragmented to enhance traffic shaping capabilities.
\Cref{sec:impl-architecture} describes how the protocol design was mapped to the actual software components, including noteworthy architectural changes and cryptographic interfaces.
\Cref{sec:deployment} provides practical guidance for the deployment and use of the system, with attention to real-world integration barriers.
Finally, \cref{sec:challenges-learnings} discusses the key challenges encountered during development and how they were addressed.

\section{Technology Stack and Environment} \label{sec:tech-stack}

The implementation created as part of this thesis is available via GitLab. It consists of two parts: A fork of the lyrebird project \cite{lyrebird} where the \drivel{} pluggable transport is implemented\footnote{See \url{https://gitlab.ethz.ch/himarc/lyrebird-pq-obfs}}, and a larger repository which includes a testing and benchmarking framework, analysis code and TeX sources of this document\footnote{See \url{https://gitlab.ethz.ch/himarc/thesis-quantumsafe-fep}}.

\paragraph{Structure of the lyrebird Fork and Dependencies}

The \drivel{} implementation, like the other six pluggable transports in the lyrebird repository, is written in Go. The lyrebird respoitory contains several Go modules:
\begin{itemize}
    \item \texttt{cmd} implements general pluggable transport logic and represents the program entry point.
    
    \item \texttt{common} contains various useful implementations such as cryptographically secure random number generation (CSRNG), deterministic random bit generation (DRBG), logging, probability distributions, filter objects to prevent replay attacks, SOCKS5 implementation, etc. These implementations may be reused outside of the lyrebird repository. 
    
    \item \texttt{internal} contains implementations that are only reusable within lyrebird. The upstream repository only contained an x25519 and \textsf{Elligator2}~\cite{CCS:BHKL13} implementation in this module.
    
    \item \texttt{transports} finally has submodules for each pluggable transport that each implement a common interface used by the \texttt{cmd} module. 
\end{itemize}

During the course of this thesis, the \texttt{internal} module was extensively refactored and extended. Furthermore, a new submodule \texttt{transports/drivel} was added to the \texttt{transports} module, based on a copy of the \texttt{transports/obfs4} module. We refer readers to \cref{sec:impl-architecture} for details about these changes.

External Go dependencies required for \drivel{} and not specific to other pluggable transports are limited to the following modules and versions:
\begin{itemize}
    \item \gopkgref{filippo.io/edwards25519}{v1.1.0} for easier handling of elliptic-curve cryptography,
    
    \item \gopkgref{gitlab.com/yawning/edwards25519-extra}{v0.0.0-20231005122941-2149dcafc266} for its implementation of \textsf{Elligator2}~\cite{CCS:BHKL13},
    
    \item \gopkgref{github.com/dchest/siphash}{v1.2.3} for the pseudorandom function employed in the DRBG,
    
    \item \gopkgref{github.com/open-quantum-safe/liboqs-go}{v0.0.0-20250119172907-28b5301df438} as a Go wrapper around the C library \texttt{liboqs} which provides many KEM implementations,
    
    \item \gopkgref{gitlab.torproject.org/tpo/anti-censorship/pluggable-transports/goptlib}{v1.6.0} for handling arguments passed to the pluggable transport, and
    
    \item \gopkgref{golang.org/x/crypto}{v0.32.0} for its implementation of some elliptic-curve operations, HKDF and NaCl secretbox.
\end{itemize}

Other than \texttt{liboqs-go}, all of these dependencies were present in the upstream repository and required for \obfsfour{}.

In addition to the Go modules above, \drivel{} also depends on the \href{https://github.com/open-quantum-safe/liboqs}{liboqs} C library, compiled statically from source during the build process. This archive is then included in a local build of \texttt{liboqs-go}, removing the need for lyrebird users to install \texttt{liboqs} separately.

However, the inclusion of C code also means that a fully static compilation of the forked lyrebird repository was not possible anymore in Go's default build process. The upstream repository accomplished this via the use of the flag \texttt{CGO\_ENABLED}. Instead, the final executable now requires the following dynamically linked libraries to be present on the system:
\begin{itemize}
    \item \texttt{linux-vdso.so.1}
    \item \texttt{libresolv.so.2}
    \item \texttt{libpthread.so.0}
    \item \texttt{libc.so.6}
    \item \texttt{/lib64/ld-linux-x86-64.so.2}
\end{itemize}

To run end-to-end tests, the official bridge setup guide \cite{tor-bridge-setup} refers, among other options, to a Docker container \cite{tor-bridge-docker}.
We were able to adapt the container's configuration to use our forked repository and our modified build process instead of the upstream version. The required dynamic libraries were already present on the system, demonstrating that deployment should not be hindered by our modifications to the dependencies and executable.

\paragraph{Testing and Benchmarking}

To perform unit and integration tests of the different software components, Go's built-in support for testing and benchmarking files was used. We have transferred all existing test cases for \obfsfour{} and extended them to include all new software components, and cover all enabled KEM/OKEM combinations.

In particular, cryptographic operations within \drivel{} are tested using positive and negative test cases on different levels. Unit tests verify the submodule's correctness, and integration tests simulate entire handshakes, including (de)serialization of messages to and from byte strings.

The tests include a small variant that performs fewer tests of randomized functions, making a trade-off between execution time and completeness. All tests pass for the entire forked repository, also in their more extensive variant. 

Benchmarks are also performed on multiple levels, including single KEM and OKEM operations (key generation, encapsulation, and decapsulation), as well as the execution of a complete simulated handshake. The latter benchmark allows a direct comparison to the corresponding \obfsfour{} benchmark. Furthermore, profiling can easily be performed to identify bottlenecks in the benchmark's performance and to quantify contributions to its memory consumption.

The results were collected and analyzed in Python and R. Further discussion of the results follows in \cref{ch:results}.

\section{Choosing Parameter Sets} \label{sec:parameters}

Although \drivel{} can be instantiated with any choice of KEM or OKEM, most combinations lead to inconsistent security levels or excessive message sizes. To reduce the number of combinations to a sensible amount, \cref{tab:drivel-params} defines a total of 12 sets of KEM/OKEM combinations, four matching each of the NIST security levels 1, 3, and 5.

These parameter sets prioritize the combinations leading to the smallest required total handshake traffic, excluding padding.

The following OKEMs were considered for each NIST security level:
\begin{itemize}
    \item ML-Kemeleon, as in \cite{irtf-cfrg-kemeleon-00}, based on ML-KEM-512 (level 1), ML-KEM-768 (level 3), and ML-KEM-1024 (level 5)
    \item Unmodified FrodoKEM \cite{NISTPQC-R3:FrodoKEM20}, concretely FrodoKEM-640-AES (level 1), FrodoKEM-976-AES (level 3), and FrodoKEM-1344-AES (level 5)
    \item Unmodified Classic McEliece, as in \cref{sec:obfuscating-classic-mceliece}, concretely Classic-McEliece-348864 (level 1), Classic-McEliece-460896 (level 3), and Classic-McEliece-6688128 (smallest ciphertext size for level 5)
    \item $\feo[\mathsf{HQC}, E_\mathsf{HQC}]$, as in \cref{sec:obfuscating-hqc}, concretely based on HQC-128 (level 1), HQC-192 (level 3), and HQC-256 (level 5)
\end{itemize}

The following unobfuscated KEMs were considered for each NIST security level:
\begin{itemize}
    \item BIKE \cite{NISTPQC-R4:BIKE22}, concretely BIKE-L1 (level 1), BIKE-L3 (level 3), and BIKE-L5 (level 5)
    \item Unobfuscated variants for each OKEM above 
\end{itemize}

\begin{table}
    \centering  \footnotesize
    \begin{tabular}{@{} L{0.1\textwidth-\tabcolsep} | L{0.16\textwidth-2\tabcolsep} L{0.17\textwidth-2\tabcolsep} L{0.32\textwidth-2\tabcolsep} R{0.11\textwidth-2\tabcolsep} R{0.14\textwidth-\tabcolsep} @{}}
    NIST Security\newline Level & Parameter Set\newline Name & KEM\newline Component & OKEM\newline Component & Total Traffic & First Fragment \\ \hline
    \multirow{4}{*}{Level 1} & drivel-L1a & ML-KEM-512 & ML-Kemeleon-512 & 2 541 & 893 \\
     & drivel-L1b & BIKE-L1 & ML-Kemeleon-512 & 4 087 & 893 \\
     & drivel-L1c & ML-KEM-512 & FEO-HQC-128 & 6 097 & 4 449 \\
     & drivel-L1d & ML-KEM-512 & Classic-McEliece-348864 & 1760 & 112 \\ \hline
    \multirow{4}{*}{Level 3} & drivel-L3a & ML-KEM-768 & ML-Kemeleon-768 & 3 620 & 1 268 \\
     & drivel-L3b & BIKE-L3 & ML-Kemeleon-768 & 7 546 & 1 268 \\
     & drivel-L3c & ML-KEM-768 & FEO-HQC-192 & 11 346 & 8 994 \\
     & drivel-L3d & ML-KEM-768 & Classic-McEliece-460896 & 2 524 & 172 \\ \hline
    \multirow{4}{*}{Level 5} & drivel-L5a & ML-KEM-1024 & ML-Kemeleon-1024 & 4 890 & 1 674 \\
     & drivel-L5b & BIKE-L5 & ML-Kemeleon-1024 & 12 030 & 1 674 \\
     & drivel-L5c & ML-KEM-1024 & FEO-HQC-256 & 17 653 & 14 437 \\
     & drivel-L5d & ML-KEM-1024 & Classic-McEliece-6688128 & 3 440 & 224
    \end{tabular}
    \caption[
        Definitions of parameter sets for \drivel{}, used in later experiments.
    ]{
        Definitions of parameter sets for \drivel{}, used in later experiments.
        Total traffic shows the combined number of bytes required across all handshake messages, excluding padding. First fragment denotes the size in bytes of just OKEM ciphertext and a 16 byte PRF value and thus illustrates the minimum amount of valid data required before the bridge may reply.
    }
    \label{tab:drivel-params}
\end{table}

Notably, HQC is not included as an unobfuscated KEM in any parameter set, due to its higher public key size compared to e.g. ML-KEM. Due to its more conservative assumptions, but consequently higher higher public key and ciphertext sizes, FrodoKEM is not included as KEM or OKEM in any parameter set. Depending on the assumptions one is comfortable with, ``a'' parameter sets may be suitable as only one KEM has to remain unbroken, whereas ``b'' would avoid a full confidentiality and obfuscation breakdown due to its use of different KEM and OKEM, while ``c'' parameter sets feature a simpler encoding routine. Finally, ``d'' parameter sets employ Classic McEliece as an OKEM directly and require confidence in its pseudorandomness (see \cref{sec:obfuscating-classic-mceliece}), but offer significantly smaller message sizes.

\section{Protocol Design} \label{sec:protocol-design}

For a definition of the \drivel{} protocol, as we implemented it in the course of this thesis, we refer readers to \cite[Figure~6]{EPRINT:GRSV25}, which served as our primary source.
This section quickly discusses how we chose to instantiate the generic primitives in the above source before diving into a theoretical discussion on proposed improvements to the protocol to better support traffic shaping.

\subsection{Instantiating the Drivel Protocol} \label{ssec:drivel-instance}

The specification of \drivel{} in \cite[Figure~6]{EPRINT:GRSV25} defines a handful of generic cryptographic primitives, which need to be instantiated with concrete choices before implementation.
The authors offer some recommendations in \cite[Section~4.2]{EPRINT:GRSV25}.

These include the following items:
\begin{itemize}
    \item the PRF $F_1$ is instantiated as \textsf{HDKF-Expand} with \textsf{SHA-256} \cite{C:Krawczyk10,rfc5869},
    
    \item the dual-PRF is instantiated as $F_2$ as \textsf{HMAC-SHA-256} \cite{C:BelCanKra96,KraBelCan97}, and
    
    \item the symmetric encryption scheme $SE$ is chosen to be \textsf{AES-256-CTR} with the appropriate key lengths $\keylen_1 = \keylen_2 = 256$ bits and a fixed IV of zero bytes.
\end{itemize}

We differ from the author's recommendations and the protocol specification only in two points:
\begin{enumerate}
    \item We do not use XOR as our one-time secure symmetric encryption scheme, and instead use AES in CTR mode. Using XOR would involve setting $\keylen_1 = \pklen$ and $\keylen_2 = \ctxtlen$, and the outputs of \textsf{HDKF-Expand} (used as $F_1$) are inherently limited to at most 8 160 bytes. This limitation would not affect any of our parameter sets proposed in \cref{sec:parameters}, but would lead to an avoidable loss of flexibility in the choice of KEM.

    \item The literal strings used for domain separation (such as e.g. ``:enckey1'') are prefixed with the string constant ``Drivel'', just as in \obfsfour{}. This cautionary measure helps to guarantee domain separation even in the case of reused keypairs over multiple protocol versions.
\end{enumerate}

Due to the fact that our implementation relies on AES anyway, and to reduce the amount of options to consider in the following sections, we support only AES variants of FrodoKEM. Similarly, but motivated also by a desire for a smaller traffic volume during the key exchange, Classic McEliece has been disabled as a KEM (though remains available as an OKEM). FrodoKEM variants using SHAKE, as well as unobfuscated Classic McEliece KEMs, could easily be re-enabled if so desired.

\subsection{Discussion on Fragmenting Handshake Messages} \label{ssec:fragmentation}

This section analyzes possibilities to allow for more flexibility in shaping \drivel{} traffic. Avoiding fingerprinting based on certain sizes, directionalities and timing of messages between client and bridge is crucial to evade censors.

\textbf{No changes discussed or proposed in this \cref{ssec:fragmentation} were implemented, or practically evaluated as part of this thesis, but this discussion may be valuable to readers to understand possible future directions of the protocol.}

\paragraph{Fragmentation is Needed}
When deploying \drivel{}, it may be desirable to offer even more flexibility for traffic shaping than \obfsfour{}. In particular, \obfsfour{} sends two messages in its handshake, before fragmenting packets using a customizable message size distribution based on a deterministic pseudorandom number generator and a seed determined by the bridge server.

While \drivel{} also requires two messages to complete the handshake, \obfsfour{} messages range from 141 to 8 192 bytes in length, and \drivel{} message sizes depend on the selected KEM and OKEM. Ignoring the padding for the moment, \cref{tab:frag-msg-sizes} gives an overview of the minimum message sizes required for different combinations of KEM and OKEM in \drivel{}.

\begin{table}
    \centering \small
    \begin{tabular}{@{} L{0.2\textwidth-\tabcolsep} L{0.33\textwidth-2\tabcolsep} | L{0.3\textwidth-\tabcolsep} @{}}
    KEM\newline Component & OKEM\newline Component & Minimum Sizes\newline Level 1 / Level 3 / Level 5 \\ \hline
    
    \multirow{4}{*}{\shortstack[l]{ML-KEM\\ 512 / 768 / 1024}} & Classic-McEliece\newline 348864 / 460896 / 6688128 & 928 / 1 372 / 1 808 \\
    & ML-Kemeleon\newline 512 / 768 / 1024 & 1 709 / 2 468 / 3 258 \\
    & FEO-HQC\newline 128 / 192 / 256 & 5 265 / 10 194 / 16 021 \\
    & FrodoKEM\newline 640 / 976 / 1344 & 10 552 / 16 960 / 23 232 \\ \hline

    \multirow{4}{*}{\shortstack[l]{BIKE\\ L1 / L3 / L5}} & Classic-McEliece\newline 348864 / 460896 / 6688128 & 1 669 / 3 271 / 5 362 \\
    & ML-Kemeleon\newline 512 / 768 / 1024 & 2 450 / 4 367 / 6 812 \\
    & FEO-HQC\newline 128 / 192 / 256 & 6 006 / 12 093 / 19 575 \\
    & FrodoKEM\newline 640 / 976 / 1344 & 11 293 / 18 859 / 26 786 \\ \hline

    \multirow{4}{*}{\shortstack[l]{HQC\\ 128 / 192 / 256}} & Classic-McEliece\newline 348864 / 460896 / 6688128 & 2 377 / 4 710 / 7 485 \\
    & ML-Kemeleon\newline 512 / 768 / 1024 & 3 158 / 5 806 / 8 935 \\
    & FEO-HQC\newline 128 / 192 / 256 & 6 714 / 13 532 / 21 698 \\
    & FrodoKEM\newline 640 / 976 / 1344 & 12 001 / 20 298 / 28 909 \\ \hline

    \multirow{4}{*}{\shortstack[l]{FrodoKEM\\ 640 / 976 / 1344}} & Classic-McEliece\newline 348864 / 460896 / 6688128 & 9 744 / 15 820 / 21 760 \\
    & ML-Kemeleon\newline 512 / 768 / 1024 & 10 525 / 16 916 / 23 210 \\
    & FEO-HQC\newline 128 / 192 / 256 & 14 081 / 24 642 / 35 973 \\
    & FrodoKEM\newline 640 / 976 / 1344 & 19 368 / 31 408 / 43 184
    \end{tabular}
    \caption[
        Minimum sizes in bytes for the first \drivel{} message without padding depending on the choice of KEM and OKEM
    ]{
        Minimum sizes in bytes for the first \drivel{} message without padding depending on the choice of KEM and OKEM. Each cell contains minimum sizes for NIST security levels 1, 3, and 5. In the case of Classic McEliece, specific KEM parameter sets were selected to minimize message sizes while maintaining the targeted security level. The KEM parameter sets are identified in the row and column headers.
    }
    \label{tab:frag-msg-sizes}
\end{table}

The concern in this section is that censors may observe particular traffic patterns. In particular, a bridge server never sends a reply before receiving the entire first \drivel{} or \obfsfour{} message in order to avoid probing attacks. This leads to quiet periods which may constitute an identifiable feature of the pluggable transport.

As is obvious from the table, sending the entire first \drivel{} message in full before the bridge responds (after verifying the PRF value at the end of message) leads to a large quiet period. Thus, for all but a few KEM/OKEM combinations, this quiet period would quickly be identifiable. At best, using Classic McEliece or ML-Kemeleon as an OKEM while employing ML-KEM or BIKE as a KEM still yields sizes not exceeding 8 192 bytes but the quiet periods would still be easy to distinguish from e.g. \obfsfour{} traffic.

\paragraph{Desirable Security Properties}
Before discussing the options to mitigate this risk, let us recall one of the advantages \drivel{} has over \obfsfour{}. In \obfsfour{}, censors can retroactively identify handshake packets by verifying the MAC value if the bridge information is leaked, as the MAC it is keyed only with the bridge information. This allows censors to definitively identify clients that had previously connected to a bridge, as well as any future clients connecting to the bridge. This property has been discussed in \cite[Section~6]{CCS:GunSteVei24} and was also recognized earlier by David Fifield in \cite{obfs4-pk-reveal-distinguisher}.

Instead, \drivel{} establishes a shared secret between the client and the bridge in the first message. This shared secret is then used in addition to the bridge information to key the PRF. Censors therefore cannot retroactively identify obfuscated key exchanges with certainty, unless the OKEM private key is leaked. We will refer to this property here as \emph{strong obfuscation} ($\sObf$).

For $\drivel$ to maintain its security, it is necessary that:
\begin{itemize}
    \item[a)] the bridge verifies the client's knowledge of the bridge information before sending a reply, and that
    \item[b)] the client's message proving this is indistinguishable from random bits, even given the bridge information and independent proofs from other clients.
\end{itemize}

Violating a) would make the bridge vulnerable to probing attacks by censors that do not know the bridge information. On the other hand, violating b) would trivially break $\sObf$. Both of these outcomes would be undesirable and $\sObfKE$ from \cite{CCS:GunSteVei24} captures both avenues of attack, since the predicate \textsf{Probed} automatically wins the game, and public keys can be revealed when asked to distinguish a simulated from a real transcript in \textsc{ChallExec}, respectively.

Due to the required proof in the client's initial communication alone, it is strictly necessary that the bridge server receive a certain minimum amount of data before it may respond in any way.
To break up the first large \drivel{} message, we could, for example, split it into parts and let the server respond after receiving smaller parts. However, the first such ``fragment'' would need to contain at least a suitable proof that the client knows the bridge information.

\paragraph{An Informal Security Notion}
In order to outline the above requirements a bit more, we can informally define the initial interaction between an adversary and the bridge servers. One goal, among others, is to arrive at a shared secret, that can aid in subsequent fragmentation, using just the first message from the client to the server.
This effectively means that a first fragment could be viewed as a KEM ciphertext: Bridge information is generated and distributed, a message is sent by a client to the bridge and a shared secret is computed. Conversly, the first fragment may also be viewed as a MAC tag: Bridge information is assumed to be secret and shared between two parties, and used to authenticate a communication.

Let us also assume that there is no possibility for bridges to save state about each client (e.g. similar to TLS 1.3 session resumption) and that no pre-shared symmetric keys are available (which would trivialize the entire handshake).

We will now examine what properties this exchange should satisfy:
\begin{itemize}
    \item Adversaries should not be able to distinguish the first fragment sent over the network from random bits, even given the public key (e.g. retroactively). This corresponds directly to $\ctxtunif$, if we were to view the exchange as an OKEM.

    \item Adversaries should not be able to link a shared secret to any given first fragment observed on the network. Viewing the exchange as a KEM, and accounting for possible active attacks, this corresponds to $\indcca$ security.
    
    \item Adversaries should not be able to create first fragments that, when parsed by the bridge, correspond to a valid shared secret, without access to the bridge information. This would allows bridges to respond, violating probing resistance. Here, we can view the exchange as a MAC application using the previously shared bridge information as a key. The property then corresponds to the standard notion of strongly secure MACs as defined in \cite[Definition~4.3]{katz_lindell}, \cite[Chapter~2]{AC:BelNam00}.
\end{itemize}

Note also that in the case of plain \drivel{}, these properties are achieved when using the entire first message as a ``first fragment'': The first two requirements are covered by the OKEM, and the last property is achieved by authenticating every message with a PRF value.

It is hard to imagine a significant potential in message size reduction outside of removing other components of the first \drivel{} message, as we conjecture the following: Any protocol satisfying these three requirements could act as an OKEM (or an inefficient MAC). The existence of a more efficient protocol would thus imply the existence of a more efficient OKEM, which, due to the large scope of the NIST Standardization, seems implausible. This gives us confidence that the constructions in \cref{ssec:drivel-mod} below are both close to optimal in terms of first fragment size.

\paragraph{Arbitrary Fragmentation}
We have focused on maintaining $\sObf$ security during fragmentation up until now, as this was also a design goal for \drivel{}.
If, however, compromises could be made in regards to $\sObf$ security, the fragmentation would not suffer the constraints outlined above.

Relaxing our requirements, and allowing a censor to retroactively identify bridges given their bridge information, the following fragmentation strategy becomes reasonable: The client sends a first fragment of $x+16$ bytes, consisting of $x$ bytes of randomized data and a 16 byte PRF keyed with the bridge information. Padding may be added between the two blocks. The choice of $x$ does not impact the security, but reduces the chance of bridges rejecting honest connection attempts due to repeated PRF values. In particular, the chance of collisions in those $x$ bytes must be kept small within a given epoch hour. As an example, assuming 52 active users per bridge \cite{tor-metrics}, each making 60 handshakes per epoch hour, then choosing $x=6$ random bytes already yields a collision probability around $3 \cdot 10^{-8}$ by the birthday bound.

This approach is very similar in spirit to the first message in \obfsfour{}, and allows for much more flexibility in traffic shaping through padding. The key difference from \obfsfour{} is the removal of one of the PRF values and the replacement of the obfuscated client public key by randomized data.

Sending even less data in a first fragment seems implausible, as the randomized data is used to prevent replay, and the PRF value proves knowledge of the bridge information. Using less than $x$ or 16 bytes, respectively, for either component would lower the security level or increase the collision probability between users, forcing handshake retries.

\subsection{Proposed Modifications to the Drivel Protocol} \label{ssec:drivel-mod}

\textbf{No changes discussed or proposed in this \cref{ssec:drivel-mod} were implemented or practically evaluated as part of this thesis, but this discussion may be valuable to readers to understand possible future directions of the protocol.}

\textbf{This thesis employs only the unmodified variant of $\drivel{}$ presented in \cite[Figure~6]{EPRINT:GRSV25}.}

The following two subsections offer different approaches to implement fragmentation of handshake messages in \drivel{}. \Cref{sssec:variant-minimal} tries to make only small changes to \drivel{}, as proposed in \cite[Figure~6]{EPRINT:GRSV25}, while \cref{sssec:variant-framing} tries to reuse existing mechanisms in \obfsfour{} and extend them from the data transfer to the handshake phase.

\subsubsection{Variant 1: A Minimal Fragmentation} \label{sssec:variant-minimal}

One way to achieve the security properties described in \cref{ssec:fragmentation} in a space-efficient manner would be to send one OKEM ciphertext plus a 16 byte PRF as the first fragment. The PRF would be keyed by a combination of the shared secret and the bridge information (as in \drivel{}).

Recall from \cite[Figure~6]{EPRINT:GRSV25} that the first \drivel{} message is constructed as $\mathsf{epk}_e \conc c_S \conc P_C \conc M_C \conc \mathsf{MAC}_C$, where $\mathsf{epk}_e$ is the encrypted KEM public key, $c_S$ is the OKEM ciphertext of interest, $M_C$ helps delimit the message, and $\mathsf{MAC}_C$ authenticates all preceding data.

In this fragmentation approach, we propose a minimal change to this message, such that encrypted public keys are sent later, and an additional PRF value is sent directly following the OKEM ciphertext. Reusing the same variables, parenthesizing the first fragment for clarity, and introducing $A_C \gets F_1(ES, c_S \conc \text{``:authc''})$ as an authenticator, this would lead to the following first protocol message:

\[
    \left( c_S \conc A_C \right) \conc \mathsf{epk}_e \conc P_C \conc M_C \conc \mathsf{MAC}_C .
\]

$\mathsf{msg}_C = \mathsf{epk}_e \conc c_S \conc P_C \conc M_C \conc \mathsf{MAC}_C$


Using this modified first message, the bridge may now start sending data earlier than in unmodified \drivel{}. Although it cannot send its second message before receiving $\mathsf{epk}_e$, it can send dummy data that the client will ignore.

The adapted protocol specification is visualized in \cref{fig:modified-drivel-minimal}, an adaptation of \cite[Figure~6]{EPRINT:GRSV25}. Dashed lines denote the option to send dummy data for the purpose of traffic shaping.

\begin{figure}
    \input{algorithms/drivel-minimal}
    \caption[
        The modified \drivel{} protocol, with minimal changes to support fragmentation.
    ]{
        The modified \drivel{} protocol, with minimal changes to support fragmentation.
        $\OKEM$ is an OKEM satisfying $\indcca, \sprcca$ security, and ciphertext uniformity.
        $KEM$ is an $\indonecca$-secure KEM.
        $SE$ is a length-preserving, one-time ciphertext indistinguishable, symmetric encryption scheme.
        $F_1$ is a PRF and $F_2$ is a dual PRF.
        Core differences to the \drivel{} protocol from \cite[Figure~6]{EPRINT:GRSV25} are highlighted in blue boxes.
        A dashed arrow represents the option to send an arbitrary amount of uniformly random bits for the purpose of traffic shaping.
    }
    \label{fig:modified-drivel-minimal}
\end{figure}

Implementers should note that the newly introduced $A_C$ must also be saved to protect against replay attacks. This replaces the existing replay protection in \obfsfour{} which uses $\mathsf{MAC}_C$. The same mechanism can be reused.

There is no need to check for repeats between $\mathsf{MAC}_C$ values in this variant. The goal of these checks is to prevent the server from answering on replayed messages, in order to resist active probing.
The only scenario in which an additional $\mathsf{MAC}_C$ check would be effective is for different $A_C$ values but identical $\mathsf{MAC}_C$ in two subsequent exchanges with the same server. However, since $A_S$ is fully determined by $c_S, \pk_S$ and $\mathsf{NodeID}$, the two exchanges could not use the same value of $c_S$.
Finally, active probing resistance only considers adversaries that do not know $\mathsf{NodeID}$ (otherwise probing is trivial), and therefore could not produce a valid $A_C$ for fresh values of $c_S$ without breaking the PRF security of $F_1$ (assuming that $F_2$ is a random oracle).

\Cref{tab:frag-min-needed} shows the minimum size of a first fragment using this approach for different OKEMs.

\begin{table}
    \centering \small
    \begin{tabular}{@{} L{0.1\textwidth-\tabcolsep} | R{0.3\textwidth-2\tabcolsep} R{0.2\textwidth-2\tabcolsep} R{0.2\textwidth-2\tabcolsep} R{0.2\textwidth-\tabcolsep} @{}}
        & Classic-McEliece\newline \footnotesize 348864 / 460896 / 6688128
        & ML-Kemeleon\newline 512 / 768 / 1024
        & FEO-HQC\newline 128 / 192 / 256
        & FrodoKEM\newline 640 / 976 / 1344
        \\ \hline
    Level 1 & 112 & 893 & 4 449 & 9 736 \\
    Level 3 & 172 & 1 268 & 8 994 & 15 760 \\
    Level 5 & 224 & 1 674 & 14 437 & 21 648
    \end{tabular}
    \caption[
        Minimum sizes in bytes of a first fragment before a bridge may respond depending on the choice of OKEM.
    ]{
        Minimum sizes in bytes of a first fragment before a bridge may respond depending on the choice of OKEM. Rows denote NIST security levels. Parameter sets were selected to minimize message sizes while maintaining the targeted security level. The KEM parameter sets are identified in the row and column headers.
    }
    \label{tab:frag-min-needed}
\end{table}

It follows that using Classic McEliece or ML-Kemeleon as OKEMs allows for the most freedom in choosing message sizes. Using HQC quickly produces large ciphertexts for higher security levels.

Once this first fragment has been received by the server, later fragmentation does not suffer from the same size constraints, as the use of the shared secret then effectively proves that the client knows the bridge information and that the bridge holds the OKEM private key. Exchanging almost arbitrarily small fragments becomes feasible by simply authenticating them using the shared secret and a PRF.

\subsubsection{Variant 2: Reusing \obfsfour{} Framing} \label{sssec:variant-framing}

\paragraph{Existing Fragmentation Mechanisms in obfs4}
The lyrebird repository's \obfsfour{} implementation features a packet-based system capable of transferring different types of messages during the data transfer phase. This system could be reused to implement more flexible fragmentation after the initial fragment $c_S \conc A_C$ is transmitted, but its construction duplicates part of the \drivel{} protocol.

At the time of writing, this packet-based system can be outlined as follows. Given a securely established shared secret $\mathsf{KEY\_SEED}$, client and bridge both derive two sets of the following values from it:
\begin{itemize}
    \item A 32-byte authenticated encryption (AE) key $K_\mathsf{AE}$,
    \item a 16-byte nonce prefix $\mathsf{pre}$,
    \item a 16-byte hash key $K_\mathsf{H}$, and
    \item an 8-byte hash IV $\mathsf{IV}$.
\end{itemize}

Each set of $K_\mathsf{AE}, \mathsf{pre}, K_\mathsf{H}, \mathsf{IV}$ corresponds to either the direction client-to-bridge, or bridge-to-client. Both directions work in the same way presented below and visualized in \cref{fig:framing}.

\begin{figure}
    \centering
    \includegraphics[width=\linewidth]{images/packet-framing.png}
    \caption[
        A visualization of \obfsfour{} framing at the sender.
    ]{
        A visualization of \obfsfour{} framing at the sender, where dashed shaded boxes correspond to subroutines, dashed unshaded boxes denote inputs, $\mathsf{AE}$ denotes the NaCl secretbox authenticated encryption scheme, and $H$ denotes the SipHash-2-4 pseudorandom function. 
    }
    \label{fig:framing}
\end{figure}

To create a packet, a packet type and the payload are required. The packet is then constructed and consists of the following:
\begin{itemize}
    \item A 1-byte packet type (corresponding to ``Payload'' or ``PrngSeed''),
    \item a 2-byte payload length in big endian format,
    \item the payload data itself, and
    \item configurable amounts of zero-padding (not included in the length calculation).
\end{itemize}

This packet is then passed on to a framing layer. While the packet layer ensures that a reliably received data stream can be decoded into separate variable-length messages with associated types, the framing layer's job is to encrypt, authenticate, and obfuscate the data.

For each direction, a counter value $\mathsf{counter}$ is initially set to 1, and a hash state $S$ is initialized to $\mathsf{IV}$.

For each frame (consisting of one or more packets) passed to the framing layer, several things occur:
\begin{enumerate}
    \item A nonce is computed as $ \mathsf{pre} \conc \mathsf{counter}$, and $\mathsf{counter}$ is incremented.
    \item One step of SipHash-2-4 in OFB mode is computed, yielding a fresh 8-byte hash state $S \gets H(K_\mathsf{H}, S)$.
\end{enumerate}

The entire packet is then encrypted using NaCl secretbox (Poly1305/XSalsa20) authenticated encryption with key $K_\mathsf{AE}$, producing a ciphertext; note that the ciphertext is longer than the packet payload, as padding and the secretbox overhead are now included.

The length of the ciphertext is then XORed with the first two bytes of the newly computed state $S$. The final datagram consists of:
\begin{itemize}
    \item A 2-byte obfuscated length field, and
    \item the AE ciphertext.
\end{itemize}

Upon receiving a packet, the receiver updates its $\mathsf{counter}$ and $S$ values, deobfuscated the length field, and decrypts the AE ciphertext. Finally, the data is passed up to the packet layer.

\paragraph{An Informal Security Analysis}

We will now discuss the achieved security guarantees by the above approach, to quickly survey possible improvements in future implementations.

The framing layer outlined above cannot, by design of the underlying Tor pluggable transport implementation, hide the length of transmitted frames from active attackers.
After the initial handshake, the connection is ``wrapped'' in the packet and framing layers, and for as long as the connections stay alive, data is passed back and forth between the local Tor client (in plaintext) and the bridge connection (encoded in packets).
If, at any point, a connection closes or raises an error (e.g. because a tag in the framing layer's AE ciphertext failed to verify), the connection is immediately closed, and a TCP FIN packet is sent by the OS as part of closing the TCP file descriptor.
This allows active attackers to choose any TCP burst after the initial handshake, leave the length field in the first two bytes unmodified, arbitrarily change the third byte (part of the 16 byte NaCl secretbox tag, ensuring a decryption failure later), and then slowly send one byte at a time. As the pluggable transport, after reading a valid length value, will wait for all data to arrive, and then verify the AE ciphertext, the total length of the AE ciphertext can be deduced by observing when the connection is closed.

This contrasts harshly with the handling of errors and invalid MAC values in the handshake procedure: There, a random delay between 1 and 60 seconds from the start of the connection is chosen as a deadline, and if a client causes an error in the handshake or does not send enough data in the first 30 seconds, the connection is closed only at this randomized deadline.

If active attackers attempt to fingerprint the connection by modifying the length value to provoke a closure of the connection (e.g. flipping the most significant bit, ensuring an invalid length), the length value is instead chosen as a random valid length between 16 to 1446 bytes. As the connection then remains blocked until the corresponding amount of AE ciphertext is received before the connection is closed, this attack cannot provoke a closure after a fixed, identifiable amount of data.

The main purpose of the length field obfuscation is therefore not to hide it from active attackers, or protect against manipulation (this is done by the authenticated encryption), but instead to make the protocol harder to identify. To this end, it is not clear to us, why $S$ is not instead chosen as e.g. $S \gets H(K_H, \mathsf{counter})$ to obtain a similarly secure random value to use in the XOR operation. This would remove the need for $\mathsf{IV}, S$ altogether and streamline the construction. Additionally, the \drivel{} PRF $F_1$ could be reused, reducing the number of primitives required in the protocol.

\paragraph{Design Conflicts and Conclusion}

To construct a system capable of flexible traffic shaping, it is necessary to split large messages into smaller ones, sent in sequence, as well as to pad small messages to a larger size, or even send only padding when no message is available.

The existing packet-based system in \obfsfour{} achieves exactly this, while providing authentication and side-stepping attacks from \cite{SP:AlbPatWat09}. Each packet incurs an overhead of 3 bytes plus configurable padding, and each frame (containing one or more packets, depending on the bridge configuration) adds 18 bytes.
The only precondition is a securely shared $\mathsf{KEY\_SEED}$.

It is possible to employ this system (possibly changing the employed schemes to match the security levels) directly in \drivel{}, using e.g. the early secret $ES$ after transmitting $c_S \conc A_C$ without encoding, and later switching to $\mathsf{KEY\_SEED}$ after the handshake is completed.

However, since the framing layer already aims to provide obfuscation, integrity, and confidentiality, the need for $P_C, M_C, \mathsf{MAC}_C, P_S, M_S, \mathsf{MAC}_S$ would disappear. Note that the message transcript is implicitly validated by including the $\mathsf{context}$ value when calculating $\mathsf{KEY\_SEED}$. Furthermore, it would not be necessary to encrypt $\pk_e$ at all.

We believe it to be worthwhile to modify \drivel{} accordingly, allowing almost arbitrary traffic shaping after an initial transmission of only $c_S \conc A_C$.
Conversely, this rather extensive change would require adapting the extensive $\sObfKE$ security proof for \drivel{} presented in \cite{EPRINT:GRSV25}.

This approach is visualized in \cref{fig:modified-drivel-framing}, an adaptation of \cite[Figure~6]{EPRINT:GRSV25}. Let $FL$ denote the framing layer presented above. Then $FL.\mathsf{Rekey}(k)$ indicates that the framing layer is reinitialized using $k$ as the $\mathsf{KEY\_SEED}$ value following the process outlined above.

\begin{figure}
    \input{algorithms/drivel-framing}
    \caption[
        The modified \drivel{} protocol, simplified to take advantage of a framing layer.
    ]{
        The modified \drivel{} protocol, simplified to take advantage of a framing layer.
        $\OKEM$ is an OKEM satisfying $\indcca, \sprcca$ security, and ciphertext uniformity.
        $KEM$ is an $\indonecca$-secure KEM.
        $FL$ is a framing layer similar to the one described in \cref{sssec:variant-framing}.
        $F_1$ is a PRF and $F_2$ is a dual PRF.
        $\mathbf{H}$ is a collision-resistant hash function.
        Core differences to the \drivel{} protocol from \cite[Figure~6]{EPRINT:GRSV25} are highlighted in blue boxes.
        Messages are easily parsed due the the packet layer providing boundaries and the fixed-length components.
        A dashed arrow represents the option to send an arbitrary amount of uniformly random bits for the purpose of traffic shaping, e.g. by sending packets consisting only of padding.
        Dotted lines delimit the framing layer phases between $FL.\mathsf{Rekey}$ operations.
    }
    \label{fig:modified-drivel-framing}
\end{figure}

\paragraph{Note to Implementers and Future Work}

Should readers choose to implement or improve upon this proposed variant of \drivel{}, we encourage them to also consider the following items:

\begin{itemize}
    \item Calculating $\mathbf{H}(\mathsf{context}_2)$ can be done efficiently by reusing the hash state after digesting $\mathsf{context}_2$, avoiding the need to hash $\mathsf{context}_1$ twice. The hash outputs can be reused for two invocations of $F_1$ each time.
    
    \item This variant does not have a security proof like \drivel{}, and producing one would require formalizing the guarantees provided by the framing layer.

    \item As this thesis focuses on the key exchange phase, we did not propose improvements to the framing layer. However, previous work in this space exists \cite{Fenske2024} and should be considered to improve the framing layer from \obfsfour{}.

    \item Attention should be paid in particular to preventing modifications to the length fields (e.g. by authenticating them using fixed-length fields), and to handling errors consistently as discussed in the security analysis above and in \cite[Section~3.3]{Fenske2024}.

\end{itemize}

\section{Core Architecture} \label{sec:impl-architecture}
% TODO
% \Cref{sec:impl-architecture} describes how the protocol design was mapped to actual software components, including noteworthy architectural changes and cryptographic interfaces.

\paragraph{Building a KEM and OKEM from the \texttt{internal/x25519ell2} Module}

In the implementation of \obfsfour{}, only one method of key exchange is available: Customized Diffie-Hellman key exchange on the elliptic curve x25519, possibly using the \textsf{Elligator2} encoding on the curve points transmitted over the wire.

Post-quantum key-exchange algorithms are almost universally specified using the syntax of KEMs. In order to compare \drivel{} performance in the traditional setting with its performance using post-quantum KEMs, we have extended the \texttt{internal/x25519ell2} module to implement a KEM and a filter-encode obfuscator performing \textsf{Elligator2}. \Cref{fig:impl-x25519-kem} shows pseudocode illustrating the usage of the module by \obfsfour{} (through its use of the \texttt{common/ntor} module), alongside the construction of our x25519 KEM.

As our goal is simply to show how the KEM construction was extracted from the existing code, we omit the full definition of \obfsfour{} here. Suffice to say, the protocol involves one static keypair $\pk_\mathsf{id}, \sk_\mathsf{id}$ (the public key is part of the bridge information) and two ephemeral keypairs generated during the handshake procedure. The static keypair has no encodings applied to the public key (as it is transmitted out-of-band), while the ephemeral keypairs also have obfuscated public keys. When all required values are available, methods $\mathsf{ServerHandshake}, \mathsf{ClientHandshake}$ are executed to compute shared secrets which in turn are used to authenticate and finalize the handshake.

Readers should note that, although the construction is similar in spirit to the DHKEM construction \cite[Section~4.1]{rfc9180}, this KEM has minor differences in the derivation of its shared secret. Instead, the focus was on staying as close as possible to the construction used in \obfsfour{}, in order to offer a fair comparison between the two pluggable transport constructions when targeting traditional security.

Unlike in the \obfsfour{} protocol, the newly constructed KEM has what initially appear to be slightly different semantics to generate the obfuscated ciphertext $\hat \pk$:
In \obfsfour{} and its method $\mathsf{NewKeypair}$, the value $u$ determined by $\sk$ is passed directly to $\mathsf{uToRepresentative}$ whereas in the KEM, additional serialization ($\mathsf{Bytes}$) and deserialization ($\mathsf{SetBytes}$) takes place before $\mathsf{uToRepresentative}$ is invoked.
We have experimentally verified that this does not change $u$ and that the same $\hat \pk$ values are generated with both approaches, given the same randomness $t$.
Finally, the randomness $t$ is not taken from the hash function output used to set $\sk$, but rather generated securely on-the-fly. It is merely used for padding with two random bits, and to pick the sign of the curve point's y-coordinate at random as suggested in \cite{elligatorExplicitFormulas}.

\begin{figure}
    \input{algorithms/x25519-kem}
    \caption[
        Pseudocode illustrating the x25519 KEM and filter-encode obfuscator added to the \texttt{internal/x25519ell2} module.
    ]{
        Pseudocode illustrating the x25519 KEM $\KEM$ and a filter-encode obfuscator $E$, both added to the \texttt{internal/x25519ell2} module.
        The left-hand side of the figure shows the usage of the x25519 module by \obfsfour{}, while the right-hand side defines a KEM and obfuscator for use in \drivel{}.
        The aborts identify insecure secrets caused by low-order public keys.
        We use $\mathsf{firstBytes}(x, \ell), \mathsf{lastBytes}(x, \ell)$ to denote selecting the first or last $\ell$ bytes of $x$, respectively.
        $\mathsf{curve25519}$ denotes the submodule of \texttt{golang.org/x/crypto} by the same name, all other functions are from the lyrebird repository's \texttt{internal/x25519ell2} and \texttt{common/ntor} modules.
    }
    \label{fig:impl-x25519-kem}
\end{figure}

\paragraph{Adding Crypto-Agility to the \texttt{internal} Module}

Observing the current need for post-quantum key exchange, combined with the increasing deployment of newly standardized algorithms, it seems prudent to implement at least compile-time flexibility in the utilized key exchange schemes. Being able to exchange cryptographic algorithms is often called ``being crypto-agile''.

To this end, the \drivel{} implementation contains string constants identifying the desired KEM and OKEM. The data structures for the schemes are then loaded at runtime based on these strings.
The schemes are identified by the following naming convention:
\begin{itemize}
    \item The string "x25519" refers to the unobfuscated, newly implemented KEM from \cref{fig:impl-x25519-kem},
    \item all other strings denote \texttt{liboqs} KEMs, and
    \item any KEM with a corresponding filter-encode obfuscator can be used to request an OKEM under the KEM name prefixed with ``FEO-'', e.g. ``FEO-x25519'' would denote $\feo[\KEM, E]$ using the components from \cref{fig:impl-x25519-kem}.
\end{itemize}

TODO: cryptofactory, kem/okem interfaces

\paragraph{Notable Differences between \texttt{transports/drivel} and \texttt{transports/obfs4}}

TODO: Implementation changes

\section{Deployment and Integration Guide} \label{sec:deployment}
% TODO
% \Cref{sec:deployment} provides practical guidance for the deployment and use of the system, with attention to real-world integration barriers.

% * How to deploy (same as lyrebird)
% * How to use (added pk files)
% * Integration barriers: Choosing KEM/OKEM, different SOCKS integration

\section{Challenges and Lessons Learned} \label{sec:challenges-learnings}
% TODO
% Finally, \cref{sec:challenges-learnings} discusses key challenges encountered during development and how they were addressed.

% * Having keys too large to derive HKDF key streams (8b counter not enough), switched to AES-CTR
% * Lack of client arguments to choose KEM/OKEM combination, requiring extra file for public keys
% * Note somewhere that we use the non-rejecting variant of Kemeleon
% * Debugging I-D for Kemeleon:
%    * https://github.com/rozbb/ct-kemeleon/blob/main/src/lib.rs#L69 does not implement SamplePreimage and directly encodes
%    * lists partial preimage equivalence sets https://github.com/jmwample/kemeleon/blob/main/src/kemeleon/ciphertext/precomputed.rs
%      we used these to improve SamplePreimage code. But does not have uniform distribution in https://github.com/jmwample/kemeleon/blob/main/src/kemeleon/ciphertext.rs#L150
% * Needing to hash the same data multiple times for different F_1 calls (luckily our choice of output length requires only one block ever)